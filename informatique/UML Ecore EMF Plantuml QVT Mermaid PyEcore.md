# UML

UML (Unified Modeling Language) est toujours utilisé dans le développement logiciel et est considéré comme l'un des langages de modélisation les plus couramment utilisés. Bien que de nouveaux outils et langages aient émergé ces dernières années, UML reste populaire pour sa capacité à communiquer efficacement des concepts de conception et à décrire les systèmes de manière claire et cohérente.

Depuis sa première apparition en 1997, UML a connu plusieurs révisions et mises à jour pour s'adapter aux évolutions du développement logiciel. La dernière version de la spécification UML est UML 2.5.1, publiée en 2017.

De plus, les pratiques de développement agile ont conduit à une adoption plus pragmatique de la modélisation UML. Les diagrammes UML sont souvent utilisés dans le cadre de la documentation du système ou pour clarifier la conception, mais ils ne sont plus considérés comme indispensables dans le processus de développement logiciel agile.

En résumé, bien que UML ne soit plus aussi central dans les méthodologies de développement de logiciels qu'il l'était auparavant, il reste un langage de modélisation populaire et largement utilisé dans l'industrie.

# MDA

MDA (Model Driven Architecture) est une approche de développement logiciel basée sur l'utilisation de modèles formels pour spécifier, concevoir et générer des systèmes logiciels.

La démarche MDA repose sur l'utilisation d'un modèle de plateforme indépendant (PIM) qui décrit la fonctionnalité du système de manière abstraite, indépendamment des détails de mise en œuvre. Le PIM est ensuite transformé en un modèle de plateforme spécifique (PSM) qui décrit les détails de mise en œuvre du système pour une plateforme cible particulière.

La spécification de modèles dans MDA repose sur l'utilisation d'un métamodèle appelé MOF (Meta Object Facility) qui fournit une définition formelle pour la construction de modèles. Les modèles sont définis en utilisant un langage de modélisation comme UML.

Bien que la démarche MDA ait été initialement proposée comme une approche pour la conception de systèmes d'entreprise, elle peut être appliquée à un large éventail de domaines et de types de systèmes.

En résumé, MDA est une approche de développement logiciel basée sur l'utilisation de modèles formels pour concevoir et générer des systèmes logiciels. Bien que MDA ait connu une adoption limitée dans l'industrie, elle reste une méthode intéressante pour la conception et la génération de systèmes logiciels à partir de modèles abstraits.

# OASIS

L'initiative OASIS (Organization for the Advancement of Structured Information Standards) est un consortium international de normalisation qui développe des normes pour les technologies de l'information et de la communication (TIC). Fondé en 1993, OASIS a pour mission de promouvoir l'interopérabilité des systèmes informatiques en développant des normes ouvertes et neutres, indépendantes des fournisseurs et basées sur un consensus de l'industrie.

OASIS est impliqué dans le développement de normes pour de nombreux domaines, notamment les services web, la sécurité, la gestion des identités, la gouvernance des données, les formats de documents, l'Internet des objets (IoT), la blockchain et la cryptographie. Certaines des normes les plus populaires développées par OASIS comprennent les spécifications de services web WS-Security, SAML, XACML, UBL, DocBook, MQTT, etc.

OASIS est également connu pour son engagement en faveur de l'interopérabilité et de l'adoption de normes ouvertes, ce qui lui a valu de recevoir plusieurs prix et reconnaissances. Les membres d'OASIS comprennent des organisations de l'industrie, des gouvernements, des universités et des particuliers.

En résumé, l'initiative OASIS est un consortium international de normalisation qui développe des normes ouvertes et neutres pour les technologies de l'information et de la communication, afin de promouvoir l'interopérabilité des systèmes informatiques. OASIS est impliqué dans le développement de normes pour de nombreux domaines, notamment les services web, la sécurité, la gouvernance des données, l'IoT, la blockchain et la cryptographie.

# QVT

QVT (Query/View/Transformation) est un langage de transformation de modèles standardisé par l'Object Management Group (OMG) qui permet de décrire des transformations de modèles en utilisant des règles de correspondance et de transformation. QVT permet de spécifier des règles qui décrivent comment transformer un modèle source en un modèle cible, en utilisant une syntaxe formelle.

QVT se compose de trois langages différents : QVT Relations, QVT Operational et QVT Core. QVT Relations est destiné aux transformations relationnelles, QVT Operational est destiné aux transformations procédurales, et QVT Core fournit une syntaxe de base pour les deux langages précédents.

Les transformations de modèles peuvent être utilisées dans de nombreuses applications, telles que la migration de données, la génération de code, la synchronisation de modèles, la validation de modèles et la vérification de conformité des modèles. Les transformations de modèles peuvent également être utilisées pour générer automatiquement des modèles de code à partir de modèles de conception de haut niveau.

En résumé, QVT est un langage de transformation de modèles standardisé par l'OMG qui permet de décrire des transformations de modèles en utilisant des règles de correspondance et de transformation. Les transformations de modèles peuvent être utilisées dans de nombreuses applications pour la migration de données, la génération de code, la synchronisation de modèles, la validation de modèles et la vérification de conformité des modèles.

# MOF (Meta Object Facility)

MOF (Meta Object Facility) est un métamodèle développé par l'Object Management Group (OMG) pour la spécification de modèles. MOF fournit une structure de base pour la définition de modèles formels, qui peuvent être utilisés pour décrire des systèmes logiciels, des architectures de systèmes d'information, des modèles de données, etc.

MOF est une norme internationale largement adoptée et est utilisé dans de nombreuses autres normes OMG, telles que UML, CWM et BPMN. MOF est également un composant clé de la démarche MDA (Model Driven Architecture), qui utilise des modèles formels pour concevoir et générer des systèmes logiciels.

Actuellement, MOF est en version 2.5.1 et a été publié en novembre 2018. La dernière version de MOF inclut des améliorations pour les modèles d'information, la gestion de version, la gestion des modèles, ainsi que des améliorations pour l'intégration avec d'autres normes OMG.

En résumé, MOF est un métamodèle développé par l'OMG pour la spécification de modèles. MOF est une norme internationale largement adoptée et est utilisé dans de nombreuses autres normes OMG, telles que UML, CWM et BPMN. MOF est actuellement en version 2.5.1 et a été publié en novembre 2018.

# QVTO

QVTO (QVT Operational) est un langage de transformation de modèles basé sur des règles et standardisé par l'Object Management Group (OMG) dans le cadre de la spécification QVT (Query/View/Transformation). QVTO est un langage de transformation de modèle procédural qui permet de décrire des transformations de modèles en utilisant des instructions impératives, telles que des boucles, des structures conditionnelles, des appels de fonctions, etc.

QVTO est destiné à être utilisé pour des transformations de modèles complexes, notamment pour les transformations entre des modèles hétérogènes, les transformations de modèles basées sur des conditions et les transformations de modèles qui nécessitent une validation de contraintes. Les transformations de modèles QVTO peuvent être utilisées pour générer du code à partir de modèles, pour synchroniser des modèles, pour transformer des modèles dans différents formats, etc.

QVTO est utilisé en combinaison avec d'autres langages de modélisation, tels que MOF (Meta Object Facility), pour décrire les modèles source et cible. QVTO fournit des fonctionnalités de transformation de modèle flexibles et puissantes, qui peuvent être utilisées pour transformer des modèles dans différents formats, pour automatiser des tâches de développement de logiciels et pour réduire les coûts et les délais de développement.

En résumé, QVTO est un langage de transformation de modèles procédural basé sur des règles et standardisé par l'OMG dans le cadre de la spécification QVT. QVTO est utilisé pour des transformations de modèles complexes, notamment pour les transformations entre des modèles hétérogènes, les transformations de modèles basées sur des conditions et les transformations de modèles qui nécessitent une validation de contraintes. QVTO est utilisé en combinaison avec d'autres langages de modélisation, tels que MOF, pour décrire les modèles source et cible.

# M2T (Model to text)

Model to Text (M2T) est une approche de génération de code qui utilise des modèles pour décrire le code source. Avec M2T, le code source est généré automatiquement à partir d'un modèle, ce qui permet de réduire les coûts et les délais de développement tout en améliorant la qualité du code.

Actuellement, M2T est largement utilisé dans les environnements de développement de logiciels et est pris en charge par de nombreux outils de développement de modèles, tels que Eclipse Modeling Framework, Xtext, Acceleo, etc. Les outils de développement de modèles permettent aux développeurs de décrire des modèles de domaines spécifiques et de générer du code source à partir de ces modèles.

En outre, M2T est souvent utilisé en combinaison avec d'autres approches de développement de modèles, telles que Model Driven Architecture (MDA) et Model Driven Engineering (MDE), pour créer des systèmes logiciels hautement automatisés. M2T est également compatible avec de nombreux langages de programmation, tels que Java, C++, C#, Python, etc.

En résumé, Model to Text est une approche de génération de code qui utilise des modèles pour décrire le code source. Actuellement, M2T est largement utilisé dans les environnements de développement de logiciels et est pris en charge par de nombreux outils de développement de modèles. M2T est souvent utilisé en combinaison avec d'autres approches de développement de modèles, telles que MDA et MDE, pour créer des systèmes logiciels hautement automatisés.

# M2G (Model to grammar)

Model to Grammar (M2G) est une approche de développement de langage de programmation qui utilise des modèles pour décrire la syntaxe et la sémantique d'un langage de programmation. Avec M2G, le compilateur est généré automatiquement à partir d'un modèle, ce qui permet de réduire les coûts et les délais de développement tout en améliorant la qualité du compilateur.

M2G est souvent utilisé pour créer des langages de programmation dédiés à un domaine spécifique, tels que les langages de script pour l'automatisation de tests, les langages de description de données pour les bases de données, etc. Les langages de programmation créés avec M2G sont généralement plus simples à utiliser que les langages de programmation généraux, car ils sont spécifiquement conçus pour répondre aux besoins du domaine.

M2G est généralement pris en charge par des outils de développement de modèles, tels que Eclipse Modeling Framework, Xtext, ANTLR, etc. Ces outils permettent aux développeurs de décrire des modèles de syntaxe et de sémantique de langages de programmation spécifiques à un domaine, et de générer automatiquement un compilateur à partir de ces modèles.

En résumé, Model to Grammar est une approche de développement de langage de programmation qui utilise des modèles pour décrire la syntaxe et la sémantique d'un langage de programmation. M2G est souvent utilisé pour créer des langages de programmation dédiés à un domaine spécifique, et est pris en charge par des outils de développement de modèles tels que EMF, Xtext, ANTLR, etc.
https://www.researchgate.net/publication/271845346_Master_Thesis_Grammar_and_graphical_concrete_syntaxes_generator_assistant_for_domain_specific_modeling_languages

# Les grammaires PEG

Les grammaires PEG (Parsing Expression Grammars) sont une technique pour définir la syntaxe d'un langage formel. Elles ont été proposées par Bryan Ford en 2004 comme alternative aux grammaires contextuelles et aux grammaires régulières, qui ont des limitations pour décrire des langages de programmation complets.

Les grammaires PEG sont basées sur des expressions de parsing qui sont des constructions similaires aux expressions régulières mais avec des capacités supplémentaires. Les expressions de parsing de PEG sont construites à partir de primitives comme des caractères littéraux, des ensembles de caractères, des choix, des séquences, des expressions optionnelles, des boucles et des assertions.

L'une des principales caractéristiques des grammaires PEG est leur déterminisme, c'est-à-dire qu'il n'y a pas d'ambiguïté dans la reconnaissance de la syntaxe. Cette propriété est atteinte grâce à l'ordre de priorité des règles de la grammaire, où la première règle qui correspond est celle qui est choisie.

Une autre caractéristique importante des grammaires PEG est leur capacité à gérer des règles de syntaxe récursives, ce qui permet de décrire des langages de programmation avec une syntaxe plus complexe que les grammaires régulières.

Enfin, les grammaires PEG ont une capacité intégrée de génération de code, ce qui signifie qu'il est possible de générer directement un analyseur syntaxique à partir de la grammaire PEG, ce qui facilite le processus de mise en œuvre.

En résumé, les grammaires PEG sont une technique pour définir la syntaxe d'un langage formel, basée sur des expressions de parsing. Elles ont des caractéristiques telles que le déterminisme et la capacité à gérer des règles de syntaxe récursives, ce qui en fait une alternative intéressante aux grammaires contextuelles et aux grammaires régulières pour la description de langages de programmation.

# La grammaire PEG pour PlantUML

PlantUML est un langage de dessin UML qui permet de représenter des diagrammes UML à l'aide d'une syntaxe textuelle. La grammaire PEG de PlantUML est utilisée pour analyser cette syntaxe et générer les diagrammes correspondants.

La grammaire PEG de PlantUML est assez complexe et contient de nombreuses règles. Voici un exemple de règle pour la définition d'une classe :

```
class_definition  = stereotype? ('abstract' / 'static')? 'class' identifier
    ('<' identifier (',' identifier)* '>')?
    ('{' member_definition* '}')?

```

Cette règle décrit la syntaxe pour la définition d'une classe, qui peut contenir un stéréotype optionnel, les mots-clés "abstract" ou "static" optionnels, le mot-clé "class", suivi d'un identifiant obligatoire pour le nom de la classe. La classe peut également avoir des paramètres de type optionnels, spécifiés entre des crochets angulaires et séparés par des virgules, ainsi que des définitions de membres optionnelles, spécifiées entre des accolades.

La grammaire PEG de PlantUML contient également des règles pour d'autres éléments de diagramme UML, tels que les relations entre les classes, les diagrammes de cas d'utilisation, les séquences d'interaction, etc.

Il convient de noter que la grammaire PEG de PlantUML est constamment en évolution, car de nouvelles fonctionnalités et améliorations sont ajoutées régulièrement pour permettre une syntaxe plus riche et plus expressive.

# Grammaire PEG pour mermaid

Mermaid est un langage de dessin de diagrammes qui permet de représenter différents types de diagrammes tels que des diagrammes de flux, des organigrammes, des diagrammes de séquence, etc. à l'aide d'une syntaxe textuelle simple. La grammaire PEG de Mermaid est utilisée pour analyser cette syntaxe et générer les diagrammes correspondants.

La grammaire PEG de Mermaid est assez simple et contient un nombre limité de règles. Voici un exemple de règle pour la définition d'un nœud :

```
node_stmt   = iddef '[' attr_list? ']' opt_label ':'? opt_port_edges ';'
```

Cette règle décrit la syntaxe pour la définition d'un nœud, qui peut contenir un identifiant optionnel, des attributs optionnels spécifiés entre des crochets, un label optionnel, un signe deux-points optionnel et des bords de port optionnels spécifiés entre des points-virgules.

La grammaire PEG de Mermaid contient également des règles pour d'autres éléments de diagramme tels que les bords, les groupes, les boîtes et les classes.

Il convient de noter que la grammaire PEG de Mermaid est relativement simple, mais elle offre une grande flexibilité et une grande expressivité pour décrire les diagrammes. Les développeurs peuvent ainsi créer des diagrammes complexes et personnalisés en utilisant une syntaxe simple et intuitive.

# pyecore

PyEcore est un framework Python qui permet de créer des modèles EMF (Eclipse Modeling Framework) et de les manipuler à l'aide de Python. EMF est un framework de modélisation de données basé sur le langage de modélisation UML (Unified Modeling Language) et fournit un ensemble d'outils pour la création, la manipulation et la validation de modèles UML.

PyEcore permet de définir des modèles EMF à l'aide de classes Python et de générer automatiquement du code Python correspondant à ces modèles. Les modèles définis avec PyEcore peuvent être utilisés pour la création et la manipulation de modèles UML dans une application Python.

Le framework PyEcore offre de nombreuses fonctionnalités, notamment :

-   la définition de modèles EMF à l'aide de classes Python,
-   la génération automatique de code Python à partir des modèles EMF,
-   la manipulation de modèles EMF dans une application Python,
-   la validation des modèles EMF à l'aide de contraintes OCL (Object Constraint Language),
-   la génération automatique de diagrammes de classe UML à partir des modèles EMF.

PyEcore est compatible avec les outils EMF existants, tels que l'éditeur de modèle EMF, les générateurs de code EMF, etc. Il peut également être utilisé en conjonction avec d'autres frameworks Python pour la modélisation de données, tels que SQLAlchemy, Django, etc.

En résumé, PyEcore est un outil puissant pour la création, la manipulation et la validation de modèles UML dans une application Python.


# Programming language specification language (PLS )

https://en.wikipedia.org/wiki/Programming_language_specification


# Denotational Semantics
https://en.wikipedia.org/wiki/Denotational_semantics

Denotational Semantics est une branche de la sémantique formelle qui associe un sens mathématique aux programmes informatiques, souvent exprimés en langages de programmation fonctionnels. L'objectif de cette approche est de donner une sémantique formelle et rigoureuse aux programmes, permettant ainsi de raisonner sur leur comportement de manière mathématique.

Le cœur de la denotational semantics est la construction d'une fonction mathématique qui associe à chaque programme informatique une valeur mathématique. Cette fonction est souvent définie en utilisant des domaines mathématiques tels que les ensembles, les fonctions et les ordres partiels. Les valeurs mathématiques ainsi obtenues sont appelées des "denotations" et sont utilisées pour décrire le comportement des programmes.

La denotational semantics est différente d'autres approches sémantiques, telles que la sémantique opérationnelle, qui décrivent le comportement des programmes en termes de séquences d'étapes de calcul. La denotational semantics offre une sémantique plus abstraite et mathématique, qui peut être plus facile à manipuler pour prouver des propriétés sur les programmes.

La denotational semantics a été développée dans les années 1960 par Christopher Strachey et Dana Scott. Depuis lors, elle a été appliquée à de nombreux langages de programmation fonctionnels, tels que ML, Haskell et Miranda, ainsi qu'à des langages de programmation impératifs tels que C et Pascal. Elle est également utilisée dans la conception de langages de programmation et dans la vérification formelle de logiciels.

# Operational_semantics
La sémantique opérationnelle est une approche de la sémantique formelle qui décrit le comportement des programmes informatiques en termes d'étapes de calcul. Cette approche décrit comment les programmes transforment les entrées en sorties en exécutant des séquences d'instructions.

L'approche de la sémantique opérationnelle est souvent utilisée pour décrire le comportement de langages de programmation impératifs, tels que C ou Java. Elle se concentre sur la description détaillée de chaque étape de calcul et de son effet sur l'état du programme.

Il existe deux formes principales de la sémantique opérationnelle : la sémantique opérationnelle structurale et la sémantique opérationnelle dénotationnelle. La sémantique opérationnelle structurale décrit le comportement des programmes en termes de séquences d'instructions, tandis que la sémantique opérationnelle dénotationnelle décrit le comportement des programmes en termes de fonctions mathématiques.

La sémantique opérationnelle a été introduite dans les années 1950 par des chercheurs tels que Peter Naur et Maurice Wilkes. Depuis lors, elle a été largement utilisée dans la conception et l'analyse de langages de programmation, ainsi que dans la vérification de la correction de programmes informatiques.

# BNF

Historique :

La notation BNF (Backus-Naur Form) a été développée en 1959 par John Backus et Peter Naur comme une notation pour décrire la syntaxe des langages de programmation. Depuis lors, elle a été largement utilisée dans la documentation des langages de programmation, ainsi que dans la conception de compilateurs et d'interprètes.

Plus tard, des extensions ont été développées pour la notation BNF, notamment EBNF (Extended Backus-Naur Form), qui ajoute des fonctionnalités supplémentaires pour décrire la syntaxe des langages de programmation de manière plus expressive et concise.

Description de BNF :

La notation BNF est une méthode formelle pour décrire la syntaxe d'un langage de programmation ou d'un autre type de langage formel. Elle utilise des règles de production pour décrire comment les éléments du langage peuvent être combinés pour former des constructions plus complexes. Les règles de production de BNF sont souvent écrites sous la forme suivante :

```
<non-terminal> ::= <expression>
```

Le symbole `<non-terminal>` représente un élément de la grammaire qui peut être décomposé en termes de règles de production. L'expression à droite de la flèche `::=` décrit comment `<non-terminal>` peut être construit en utilisant d'autres éléments de la grammaire ou des terminaux, qui sont des éléments du langage qui ne peuvent pas être décomposés en termes de règles de production.

Par exemple, la règle de production suivante utilise la notation BNF pour décrire un programme informatique simple qui affiche le message "Hello, world!" à l'écran :

```
<program> ::= print "Hello, world!"
```

Cette règle de production décrit comment un programme peut être construit en utilisant le mot clé "print" suivi de la chaîne de caractères "Hello, world!".

https://fr.wikipedia.org/wiki/Forme_de_Backus-Naur

# EBNF

L'EBNF est une extension de la notation BNF qui ajoute des fonctionnalités supplémentaires pour décrire la syntaxe des langages de programmation de manière plus expressive et concise. Les extensions comprennent :

-   Les groupes : permettent de grouper des éléments de la grammaire pour former des constructions plus complexes.
    
-   Les options : permettent de décrire des éléments de la grammaire qui peuvent être présents ou non.
    
-   Les répétitions : permettent de décrire des éléments de la grammaire qui peuvent se répéter plusieurs fois.
    
-   Les commentaires : permettent d'ajouter des commentaires à la grammaire pour la documentation.
    

Par exemple, la règle de production suivante utilise la notation EBNF pour décrire un programme informatique simple qui affiche le message "Hello, world!" à l'écran :

```
<program> ::= "print" "Hello, world!" ;
```

Cette règle de production utilise des guillemets pour entourer les éléments de la grammaire qui doivent apparaître dans le programme, et un point-virgule pour terminer la règle de production. Les guillemets indiquent que les éléments sont des terminaux, tandis que les éléments non entourés de guillemets sont des non-terminaux. Les crochets peuvent également être utilisés pour décrire des options, et les accolades pour décrire des répétitions.

https://fr.wikipedia.org/wiki/Extended_Backus-Naur_Form
-   BNF : [https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form)
-   EBNF : [https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form)